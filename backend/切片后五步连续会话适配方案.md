# 切片后五步连续会话适配方案

## 📋 问题分析

用户提出了一个重要问题：
> "切片后是不是还适合和大模型五步连续会话。对于局部切片需要重新设置连续会话的内容"

## 🔍 现状分析

### 1. 当前五步交互流程
现有的五步交互（Step 1-5）是基于**完整图纸**设计的：

```
Step 1: 项目与图纸基本信息识别
Step 2: 构件编号清单提取  
Step 3: 构件数量统计
Step 4: 构件定位信息
Step 5: 构件详细属性
```

### 2. 切片处理后的挑战

**问题1：上下文丢失**
- 每个切片只包含局部信息
- 缺乏全图的整体上下文
- 构件间的关联关系丢失

**问题2：步骤适配性差**
- Step 1（项目信息）：可能在每个切片中重复或缺失
- Step 2（构件清单）：每个切片只能看到局部构件
- Step 3（数量统计）：无法准确统计全图数量
- Step 4（定位信息）：坐标系统需要重新映射
- Step 5（详细属性）：属性提取相对独立，适配性较好

## 🔧 解决方案

### 方案A：分层五步交互（推荐）

#### 第一层：全图概览分析
使用**原图缩略图**进行全局五步交互：

```python
# 全图概览五步交互
def global_five_step_analysis(original_image_thumbnail):
    """
    基于原图缩略图的全局分析
    目标：获取整体项目信息和构件布局
    """
    step1_global = extract_project_info(original_image_thumbnail)
    step2_global = extract_component_overview(original_image_thumbnail)  
    step3_global = estimate_component_counts(original_image_thumbnail)
    step4_global = identify_overall_layout(original_image_thumbnail)
    step5_global = extract_general_specifications(original_image_thumbnail)
    
    return {
        'global_context': {
            'project_info': step1_global,
            'component_overview': step2_global,
            'layout_framework': step4_global
        },
        'global_estimates': step3_global,
        'general_specs': step5_global
    }
```

#### 第二层：切片详细分析
基于全局上下文，对每个切片进行**自适应三步交互**：

```python
# 切片详细分析（简化三步）
def slice_detail_analysis(slice_image, global_context, slice_position):
    """
    基于全局上下文的切片详细分析
    目标：提取切片内的详细构件信息
    """
    # 注入全局上下文
    context_prompt = f"""
    全图项目信息：{global_context['project_info']}
    整体构件概览：{global_context['component_overview']}
    当前切片位置：{slice_position}
    
    请基于以上上下文分析当前切片：
    """
    
    # 简化三步交互
    step1_slice = identify_local_components(slice_image, context_prompt)
    step2_slice = extract_detailed_dimensions(slice_image, step1_slice)
    step3_slice = extract_reinforcement_details(slice_image, step1_slice)
    
    return {
        'local_components': step1_slice,
        'detailed_dimensions': step2_slice,
        'reinforcement_info': step3_slice,
        'slice_metadata': {
            'position': slice_position,
            'global_context_used': True
        }
    }
```

### 方案B：上下文链传递（备选）

为每个切片构建**累积上下文链**：

```python
def context_chain_analysis(slices, initial_context=None):
    """
    上下文链式分析
    每个切片的分析结果会传递给下一个切片
    """
    context_chain = initial_context or {}
    slice_results = []
    
    for i, slice_info in enumerate(slices):
        # 构建当前切片的上下文
        current_context = {
            'previous_components': context_chain.get('components', []),
            'accumulated_project_info': context_chain.get('project_info', {}),
            'slice_sequence': i + 1,
            'total_slices': len(slices)
        }
        
        # 执行自适应分析
        slice_result = adaptive_slice_analysis(
            slice_info['image'], 
            current_context,
            slice_info['position']
        )
        
        # 更新上下文链
        context_chain = update_context_chain(context_chain, slice_result)
        slice_results.append(slice_result)
    
    return slice_results, context_chain
```

## 🎯 具体实现策略

### 1. 上下文注入机制

```python
class SliceContextManager:
    """切片上下文管理器"""
    
    def __init__(self, global_analysis_result):
        self.global_context = global_analysis_result
        self.slice_contexts = {}
    
    def generate_slice_prompt(self, slice_index, slice_position):
        """为特定切片生成带上下文的提示词"""
        
        base_context = f"""
        【全图项目信息】
        项目名称：{self.global_context.get('project_name', '未知')}
        图纸类型：{self.global_context.get('drawing_type', '结构图')}
        比例尺：{self.global_context.get('scale', '未知')}
        
        【整体构件布局】
        主要构件类型：{', '.join(self.global_context.get('main_component_types', []))}
        预估构件总数：{self.global_context.get('estimated_total', '未知')}
        
        【当前切片信息】
        切片位置：{slice_position}
        切片序号：{slice_index + 1}
        
        【分析要求】
        请基于以上全图上下文，重点分析当前切片中的：
        1. 具体构件详情（编号、尺寸、配筋）
        2. 构件与周边的连接关系
        3. 特殊标注和详图信息
        
        注意：
        - 保持与全图项目信息的一致性
        - 构件编号应符合整体编号规律
        - 尺寸单位应与图纸比例尺匹配
        """
        
        return base_context
```

### 2. 自适应步骤选择

```python
def adaptive_step_selection(slice_characteristics):
    """
    根据切片特征自适应选择分析步骤
    """
    steps = []
    
    # 基础步骤：构件识别（必选）
    steps.append('component_identification')
    
    # 条件步骤
    if slice_characteristics.get('has_dimensions'):
        steps.append('dimension_extraction')
    
    if slice_characteristics.get('has_reinforcement'):
        steps.append('reinforcement_analysis')
    
    if slice_characteristics.get('has_details'):
        steps.append('detail_analysis')
    
    if slice_characteristics.get('has_connections'):
        steps.append('connection_analysis')
    
    return steps
```

### 3. 结果一致性校验

```python
def validate_slice_consistency(slice_results, global_context):
    """
    校验切片结果与全局上下文的一致性
    """
    inconsistencies = []
    
    for slice_result in slice_results:
        # 检查项目信息一致性
        if slice_result.get('project_name') != global_context.get('project_name'):
            inconsistencies.append({
                'type': 'project_name_mismatch',
                'slice_value': slice_result.get('project_name'),
                'global_value': global_context.get('project_name')
            })
        
        # 检查构件编号规律
        component_ids = [c.get('id') for c in slice_result.get('components', [])]
        if not validate_component_id_pattern(component_ids, global_context):
            inconsistencies.append({
                'type': 'component_id_pattern_mismatch',
                'slice_ids': component_ids
            })
    
    return inconsistencies
```

## 📊 性能对比

| 方案 | API调用次数 | 分析精度 | 上下文完整性 | 实现复杂度 |
|------|------------|----------|-------------|-----------|
| 原始五步交互 | 5×切片数 | 中等 | 差 | 低 |
| 分层五步交互 | 5 + 3×切片数 | 高 | 好 | 中等 |
| 上下文链传递 | 动态 | 中高 | 中等 | 高 |

## 🚀 推荐实施路径

### Phase 1：全图概览增强
1. 在切片处理前，添加全图缩略图分析
2. 提取关键的项目信息和布局框架
3. 建立全局构件词典

### Phase 2：切片上下文注入
1. 为每个切片注入全局上下文
2. 实施自适应三步分析
3. 添加结果一致性校验

### Phase 3：智能合并优化
1. 基于上下文的智能去重
2. 构件关联关系推理
3. 自动质量评估和修正

## 🔧 集成到现有系统

```python
# 在 VisionScannerService 中添加
class VisionScannerService:
    
    def scan_images_with_contextual_slices(self, 
                                         image_paths: List[str],
                                         shared_slice_results: Dict[str, Any], 
                                         drawing_id: int,
                                         task_id: str = None) -> Dict[str, Any]:
        """
        基于上下文的切片Vision分析
        """
        
        # Phase 1: 全图概览分析
        global_context = self._analyze_global_overview(
            image_paths[0],  # 使用第一张图作为主图
            task_id
        )
        
        # Phase 2: 切片详细分析
        slice_results = []
        context_manager = SliceContextManager(global_context)
        
        for image_path, slice_info in shared_slice_results.items():
            if slice_info.get('sliced', False):
                slice_infos = slice_info.get('slice_infos', [])
                
                for i, slice_data in enumerate(slice_infos):
                    # 生成上下文提示
                    context_prompt = context_manager.generate_slice_prompt(
                        i, slice_data.get('position', (0, 0))
                    )
                    
                    # 执行自适应分析
                    slice_result = self._analyze_slice_with_context(
                        slice_data, context_prompt, task_id, drawing_id
                    )
                    
                    slice_results.append(slice_result)
        
        # Phase 3: 结果合并和校验
        merged_result = self._merge_contextual_results(
            global_context, slice_results, task_id, drawing_id
        )
        
        return merged_result
```

## 📝 总结

切片后的五步连续会话确实需要重新设计，推荐采用**分层五步交互**方案：

1. **全图概览层**：保持完整的五步交互，获取整体上下文
2. **切片详细层**：简化为三步交互，注入全局上下文
3. **智能合并层**：基于上下文的结果合并和校验

这样既保证了分析的完整性，又提高了切片处理的效率和准确性。 