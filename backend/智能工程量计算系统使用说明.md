# 智能工程量计算系统使用说明

## 🎯 系统概述

智能工程量计算系统是一个基于人工智能技术的建筑工程量自动计算平台，能够智能识别建筑图纸并按照国家标准自动计算工程量。

### 核心功能
- 🔍 **智能OCR识别** - 自动识别建筑图纸中的文字和符号
- 📐 **图集规范识别** - 符合国标GB/T 50105-2010建筑结构制图标准
- 🧮 **工程量计算** - 遵循GB 50500-2013建设工程工程量清单计价规范
- 💰 **造价估算** - 基于市场价格的成本分析
- 📊 **智能报告** - 生成详细的识别和计算报告

## 🏗️ 系统架构

### 技术栈
- **后端框架**: FastAPI + Python 3.8+
- **AI引擎**: YOLOv8x + PaddleOCR
- **图像处理**: OpenCV + NumPy
- **数据存储**: JSON + SQLite
- **前端界面**: React + TypeScript

### 核心模块

#### 1. 高级OCR引擎 (`advanced_ocr_engine.py`)
```python
from app.services.advanced_ocr_engine import AdvancedOCREngine

# 初始化OCR引擎
ocr_engine = AdvancedOCREngine()

# 提取文字和符号
results = ocr_engine.extract_text_and_symbols("图纸路径.jpg")
```

**功能特点:**
- 支持建筑图纸专用文字识别
- 智能提取构件代码（KZ、KL、LB等）
- 自动识别尺寸标注和材料信息
- 提供演示模式，无需安装PaddleOCR即可测试

#### 2. 图集规范识别引擎 (`atlas_recognition_engine.py`)
```python
from app.services.atlas_recognition_engine import AtlasRecognitionEngine

# 初始化图集识别引擎
atlas_engine = AtlasRecognitionEngine()

# 识别图集符号
results = atlas_engine.recognize_atlas_symbols("图纸路径.jpg", ocr_results)
```

**支持的构件符号:**
- **柱类**: KZ(框架柱)、GZ(构造柱)、LZ(梁式柱)、XZ(芯柱)
- **梁类**: KL(框架梁)、LL(连梁)、JL(基础梁)、WKL(屋面框架梁)
- **板类**: LB(楼板)、WB(屋面板)、YB(雨篷板)
- **墙类**: Q(墙)、JQ(剪力墙)、FQ(分隔墙)
- **基础类**: DJJ(独立基础)、TJJ(条形基础)、FJJ(筏形基础)

#### 3. 工程量计算引擎 (`quantity_calculation_engine.py`)
```python
from app.services.quantity_calculation_engine import QuantityCalculationEngine

# 初始化计算引擎
calc_engine = QuantityCalculationEngine()

# 计算工程量
summary = calc_engine.generate_quantity_summary(component_data)
```

**计算规则 (GB 50500-2013):**
- `010101001` - 现浇混凝土柱 (m³)
- `010101002` - 现浇混凝土梁 (m³)
- `010101003` - 现浇混凝土板 (m³)
- `010102001` - 现浇混凝土柱模板 (m²)
- `010102002` - 现浇混凝土梁模板 (m²)
- `010102003` - 现浇混凝土板模板 (m²)
- `010401001` - 钢筋 (kg)

## 🚀 快速开始

### 1. 环境准备
```bash
# 克隆项目
git clone <项目地址>
cd smart-qto-system

# 安装依赖
cd backend
pip install -r requirements.txt

# 可选：安装PaddleOCR（用于真实OCR识别）
pip install paddlepaddle paddleocr
```

### 2. 运行测试
```bash
# 测试智能工程量计算系统
python test_intelligent_quantity_system.py

# 测试单个模块
python app/services/advanced_ocr_engine.py
python app/services/atlas_recognition_engine.py
python app/services/quantity_calculation_engine.py
```

### 3. 启动Web服务
```bash
# 启动后端API服务
python -m app.main

# 访问API文档
# http://localhost:8000/docs
```

## 📋 使用流程

### 完整处理流程
```python
from test_intelligent_quantity_system import IntelligentQuantitySystem

# 1. 初始化系统
system = IntelligentQuantitySystem()

# 2. 处理建筑图纸
results = system.process_architectural_drawing("图纸路径.jpg")

# 3. 导出结果
system.export_results(results, "output/项目名称")
```

### 处理步骤详解

#### 步骤1: OCR文字识别
- 自动识别图纸中的文字内容
- 提取构件代码和编号
- 识别尺寸标注和材料信息
- 生成结构化的文本数据

#### 步骤2: 图集规范识别
- 根据国标图集匹配构件符号
- 识别图纸比例和基本信息
- 提取尺寸标注和技术参数
- 验证绘图规范符合性

#### 步骤3: 构建构件数据
- 将识别结果转换为标准构件数据
- 匹配典型尺寸和材料等级
- 建立构件之间的关联关系
- 验证数据完整性和合理性

#### 步骤4: 工程量计算
- 按照GB 50500-2013规范计算
- 自动处理扣减规则（梁柱节点、洞口等）
- 生成分项工程量清单
- 计算钢筋用量和模板面积

#### 步骤5: 生成综合报告
- 汇总识别和计算结果
- 评估数据质量和完整性
- 提供优化建议和改进方向
- 导出多种格式的报告文件

## 📊 输出结果

### 1. 综合报告 (`comprehensive_report.json`)
```json
{
  "project_info": {
    "drawing_file": "图纸文件路径",
    "processing_date": "处理日期",
    "system_version": "系统版本"
  },
  "recognition_summary": {
    "ocr_texts": "识别文本数量",
    "recognized_symbols": "识别符号数量",
    "dimensions": "识别尺寸数量"
  },
  "quantity_summary": {
    "concrete_volume": "混凝土体积(m³)",
    "formwork_area": "模板面积(m²)",
    "rebar_weight": "钢筋重量(kg)",
    "estimated_cost": "估算造价"
  }
}
```

### 2. 工程量清单 (`quantity_list.json`)
```json
{
  "010101001": {
    "name": "现浇混凝土柱",
    "unit": "m³",
    "quantity": 0.384,
    "components": [...]
  },
  "statistics": {
    "total_components": 3,
    "concrete_volume": 6.894,
    "formwork_area": 60.3,
    "rebar_weight": 539.1
  }
}
```

### 3. 完整结果 (`complete_results.json`)
包含所有处理步骤的详细数据，用于调试和分析。

## 🎯 应用场景

### 1. 建筑设计院
- 快速生成工程量清单
- 辅助方案比选和优化
- 提高设计效率和准确性

### 2. 施工企业
- 投标报价工程量计算
- 施工图预算编制
- 材料采购计划制定

### 3. 造价咨询
- 工程量复核和审查
- 造价分析和控制
- 标准化计算流程

### 4. 教育培训
- 工程量计算教学
- 规范标准学习
- 实践案例分析

## ⚙️ 配置说明

### 1. 模型配置
```python
# YOLOv8模型路径
MODEL_PATH = "app/services/models/best.pt"

# OCR引擎配置
OCR_CONFIG = {
    "use_angle_cls": True,
    "lang": "ch",
    "det_model_dir": None,
    "rec_model_dir": None
}
```

### 2. 计算参数
```python
# 钢筋用量系数 (kg/m³)
REBAR_RATIOS = {
    "column": 100,  # 柱
    "beam": 130,    # 梁
    "slab": 70      # 板
}

# 市场价格 (元)
MARKET_PRICES = {
    "concrete": 350,  # 元/m³
    "formwork": 45,   # 元/m²
    "rebar": 4.2      # 元/kg
}
```

### 3. 识别阈值
```python
# 置信度阈值
CONFIDENCE_THRESHOLD = 0.5

# 最小洞口面积 (m²)
MIN_OPENING_AREA = 0.3

# 尺寸识别精度
DIMENSION_PRECISION = 1  # mm
```

## 🔧 高级功能

### 1. 自定义构件类型
```python
# 扩展构件符号库
custom_symbols = {
    "XKZ": AtlasSymbolData(
        symbol="XKZ",
        name="型钢混凝土柱",
        category=ComponentSymbol.KZ,
        # ... 其他配置
    )
}
```

### 2. 自定义计算规则
```python
# 添加新的计算规则
def calculate_custom_component(component):
    # 自定义计算逻辑
    return {
        "custom_rule": quantity,
        "unit": "m³"
    }
```

### 3. 批量处理
```python
# 批量处理多个图纸
def batch_process(image_paths):
    system = IntelligentQuantitySystem()
    results = []
    
    for path in image_paths:
        result = system.process_architectural_drawing(path)
        results.append(result)
    
    return results
```

## 🐛 常见问题

### Q1: OCR识别效果不佳怎么办？
**A**: 
- 确保图纸清晰度足够高（建议300DPI以上）
- 检查图纸对比度，避免过暗或过亮
- 尝试调整图纸方向，确保文字水平
- 安装PaddleOCR以获得更好的识别效果

### Q2: 构件符号识别不准确？
**A**:
- 检查构件符号是否符合国标规范
- 确保符号字体清晰，避免手写体
- 验证符号编号格式（如KZ1、KL2等）
- 可以手动补充缺失的构件信息

### Q3: 工程量计算结果异常？
**A**:
- 检查构件尺寸是否合理
- 验证材料等级和规格
- 确认计算规则是否适用
- 查看扣减规则是否正确应用

### Q4: 系统运行速度慢？
**A**:
- 优化图纸分辨率，避免过大文件
- 使用GPU加速（如果可用）
- 关闭不必要的识别功能
- 考虑使用更轻量的模型

## 📈 性能优化

### 1. 图像预处理
```python
# 图像优化
def optimize_image(image_path):
    img = cv2.imread(image_path)
    # 调整大小
    img = cv2.resize(img, (1920, 1080))
    # 增强对比度
    img = cv2.convertScaleAbs(img, alpha=1.2, beta=10)
    return img
```

### 2. 并行处理
```python
# 多线程处理
from concurrent.futures import ThreadPoolExecutor

def parallel_process(image_paths):
    with ThreadPoolExecutor(max_workers=4) as executor:
        futures = [executor.submit(process_image, path) 
                  for path in image_paths]
        results = [future.result() for future in futures]
    return results
```

### 3. 缓存机制
```python
# 结果缓存
import pickle

def cache_results(results, cache_path):
    with open(cache_path, 'wb') as f:
        pickle.dump(results, f)

def load_cached_results(cache_path):
    with open(cache_path, 'rb') as f:
        return pickle.load(f)
```

## 🔄 更新日志

### v1.0.0 (2024-01-15)
- ✅ 完成核心功能开发
- ✅ 集成OCR、图集识别、工程量计算
- ✅ 支持GB 50500-2013计算规范
- ✅ 提供完整的测试用例
- ✅ 生成详细的使用文档

### 计划功能
- 🔄 支持更多图集标准
- 🔄 增加3D模型识别
- 🔄 集成BIM数据接口
- 🔄 支持云端部署
- 🔄 移动端应用开发

## 📞 技术支持

如有问题或建议，请联系：
- 📧 邮箱: support@smart-qto.com
- 🌐 官网: https://smart-qto.com
- 📱 微信: SmartQTO2024

---

**智能工程量计算系统** - 让工程量计算更智能、更准确、更高效！ 