#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
åˆ‡ç‰‡Visionåˆ†æé€‚é…å™¨
ä¸“é—¨å¤„ç†åˆ‡ç‰‡åçš„äº”æ­¥è¿ç»­ä¼šè¯ï¼Œé’ˆå¯¹å±€éƒ¨åˆ‡ç‰‡é‡æ–°è®¾ç½®è¿ç»­ä¼šè¯å†…å®¹
"""

import logging
import time
import json
from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass

logger = logging.getLogger(__name__)

@dataclass
class SliceContextConfig:
    """åˆ‡ç‰‡ä¸Šä¸‹æ–‡é…ç½®"""
    slice_index: int
    slice_id: str
    slice_bounds: Tuple[int, int, int, int]  # (x, y, width, height)
    slice_type: str  # 'detail', 'overview', 'section', etc.
    focus_areas: List[str]  # ['components', 'dimensions', 'annotations']
    original_image_size: Tuple[int, int]  # (width, height)

class SliceVisionAdapter:
    """åˆ‡ç‰‡Visionåˆ†æé€‚é…å™¨"""
    
    def __init__(self):
        self.ai_analyzer = None
        try:
            from app.services.ai_analyzer import AIAnalyzerService
            self.ai_analyzer = AIAnalyzerService()
        except Exception as e:
            logger.warning(f"âš ï¸ AIåˆ†æå™¨åˆå§‹åŒ–å¤±è´¥: {e}")

    def adapt_multi_turn_analysis_for_slices(self, 
                                            slice_configs: List[SliceContextConfig],
                                            encoded_images: List[Dict],
                                            task_id: str,
                                            drawing_id: int = None) -> Dict[str, Any]:
        """
        é’ˆå¯¹åˆ‡ç‰‡é€‚é…äº”æ­¥è¿ç»­ä¼šè¯åˆ†æ
        
        Args:
            slice_configs: åˆ‡ç‰‡é…ç½®åˆ—è¡¨
            encoded_images: ç¼–ç çš„å›¾åƒæ•°æ®
            task_id: ä»»åŠ¡ID
            drawing_id: å›¾çº¸ID
            
        Returns:
            é€‚é…åçš„åˆ†æç»“æœ
        """
        logger.info(f"ğŸ”„ å¼€å§‹åˆ‡ç‰‡é€‚é…çš„äº”æ­¥è¿ç»­ä¼šè¯åˆ†æ: {len(slice_configs)} ä¸ªåˆ‡ç‰‡")
        
        if not self.ai_analyzer or not self.ai_analyzer.is_available():
            return {
                "error": "AI Analyzer Service is not available",
                "success": False
            }
        
        slice_results = []
        
        for i, (slice_config, slice_image) in enumerate(zip(slice_configs, encoded_images)):
            logger.info(f"ğŸ” å¤„ç†åˆ‡ç‰‡ {i+1}/{len(slice_configs)}: {slice_config.slice_id}")
            
            # ä¸ºæ¯ä¸ªåˆ‡ç‰‡å®šåˆ¶äº”æ­¥ä¼šè¯
            adapted_result = self._execute_adapted_five_step_analysis(
                slice_config=slice_config,
                slice_image=slice_image,
                task_id=f"{task_id}_slice_{i}",
                drawing_id=drawing_id
            )
            
            slice_results.append({
                'slice_config': slice_config,
                'slice_index': i,
                'analysis_result': adapted_result
            })
        
        # åˆå¹¶æ‰€æœ‰åˆ‡ç‰‡ç»“æœ
        merged_result = self._merge_slice_analysis_results(slice_results, task_id)
        
        logger.info(f"âœ… åˆ‡ç‰‡é€‚é…çš„äº”æ­¥åˆ†æå®Œæˆ: {len(slice_results)} ä¸ªåˆ‡ç‰‡")
        return merged_result

    def _execute_adapted_five_step_analysis(self, 
                                          slice_config: SliceContextConfig,
                                          slice_image: Dict,
                                          task_id: str,
                                          drawing_id: int = None) -> Dict[str, Any]:
        """
        æ‰§è¡Œé’ˆå¯¹åˆ‡ç‰‡çš„é€‚é…äº”æ­¥åˆ†æ
        
        Args:
            slice_config: åˆ‡ç‰‡é…ç½®
            slice_image: åˆ‡ç‰‡å›¾åƒæ•°æ®
            task_id: ä»»åŠ¡ID
            drawing_id: å›¾çº¸ID
            
        Returns:
            åˆ†æç»“æœ
        """
        logger.info(f"ğŸ”„ å¼€å§‹é’ˆå¯¹åˆ‡ç‰‡çš„äº”æ­¥åˆ†æ: {slice_config.slice_id}")
        
        # å­˜å‚¨åˆ†æç»“æœ
        analysis_results = {
            "drawing_info": {},
            "component_ids": {},
            "component_counts": {},
            "component_positions": {},
            "component_attributes": {},
            "slice_metadata": {
                "slice_config": slice_config,
                "analysis_timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                "adaptation_method": "slice_focused"
            }
        }
        
        try:
            # Step 1: é€‚é…çš„å›¾çº¸ä¿¡æ¯æå–ï¼ˆé’ˆå¯¹åˆ‡ç‰‡ï¼‰
            step1_result = self._adapted_step1_drawing_info(slice_config, slice_image, task_id, drawing_id)
            if step1_result.get("success"):
                analysis_results["drawing_info"] = step1_result["data"]
                analysis_results["slice_metadata"]["steps_completed"] = ["step1_drawing_info"]
            
            # Step 2: é€‚é…çš„æ„ä»¶IDæå–ï¼ˆé’ˆå¯¹å±€éƒ¨åŒºåŸŸï¼‰
            step2_result = self._adapted_step2_component_ids(
                slice_config, slice_image, analysis_results["drawing_info"], task_id, drawing_id
            )
            if step2_result.get("success"):
                analysis_results["component_ids"] = step2_result["data"]
                analysis_results["slice_metadata"]["steps_completed"].append("step2_component_ids")
            
            # Step 3: é€‚é…çš„æ„ä»¶è®¡æ•°ï¼ˆé’ˆå¯¹åˆ‡ç‰‡å†…å®¹ï¼‰
            step3_result = self._adapted_step3_component_counts(
                slice_config, slice_image, analysis_results["component_ids"], task_id, drawing_id
            )
            if step3_result.get("success"):
                analysis_results["component_counts"] = step3_result["data"]
                analysis_results["slice_metadata"]["steps_completed"].append("step3_component_counts")
            
            # Step 4: é€‚é…çš„ä½ç½®ä¿¡æ¯æå–ï¼ˆç›¸å¯¹åˆ‡ç‰‡åæ ‡ï¼‰
            step4_result = self._adapted_step4_positions(
                slice_config, slice_image, analysis_results, task_id, drawing_id
            )
            if step4_result.get("success"):
                analysis_results["component_positions"] = step4_result["data"]
                analysis_results["slice_metadata"]["steps_completed"].append("step4_positions")
            
            # Step 5: é€‚é…çš„å±æ€§æå–ï¼ˆè¯¦ç»†ä¿¡æ¯ï¼‰
            step5_result = self._adapted_step5_attributes(
                slice_config, slice_image, analysis_results, task_id, drawing_id
            )
            if step5_result.get("success"):
                analysis_results["component_attributes"] = step5_result["data"]
                analysis_results["slice_metadata"]["steps_completed"].append("step5_attributes")
            
            # åˆæˆQTOæ•°æ®
            qto_data = self._synthesize_slice_qto_data(analysis_results, slice_config)
            
            return {
                "success": True,
                "qto_data": qto_data,
                "analysis_results": analysis_results,
                "slice_config": slice_config
            }
            
        except Exception as e:
            logger.error(f"âŒ åˆ‡ç‰‡äº”æ­¥åˆ†æå¤±è´¥: {e}")
            return {
                "success": False,
                "error": str(e),
                "slice_config": slice_config
            }

    def _adapted_step1_drawing_info(self, 
                                   slice_config: SliceContextConfig,
                                   slice_image: Dict,
                                   task_id: str,
                                   drawing_id: int) -> Dict[str, Any]:
        """é€‚é…çš„æ­¥éª¤1ï¼šå›¾çº¸ä¿¡æ¯æå–ï¼ˆé’ˆå¯¹åˆ‡ç‰‡ï¼‰"""
        
        # æ ¹æ®åˆ‡ç‰‡ç±»å‹è°ƒæ•´æç¤ºè¯
        if slice_config.slice_type == 'title_area':
            system_prompt = self._build_title_area_prompt()
        elif slice_config.slice_type == 'detail':
            system_prompt = self._build_detail_area_prompt()
        else:
            system_prompt = self._build_general_slice_prompt(slice_config)
        
        user_content = [
            {
                "type": "text",
                "text": f"""è¿™æ˜¯å»ºç­‘å›¾çº¸çš„ç¬¬{slice_config.slice_index + 1}ä¸ªåˆ‡ç‰‡åŒºåŸŸã€‚
åˆ‡ç‰‡ä½ç½®: ({slice_config.slice_bounds[0]}, {slice_config.slice_bounds[1]})
åˆ‡ç‰‡å°ºå¯¸: {slice_config.slice_bounds[2]}x{slice_config.slice_bounds[3]}
åŸå›¾å°ºå¯¸: {slice_config.original_image_size[0]}x{slice_config.original_image_size[1]}
åˆ‡ç‰‡ç±»å‹: {slice_config.slice_type}
å…³æ³¨åŒºåŸŸ: {', '.join(slice_config.focus_areas)}

è¯·åˆ†æè¿™ä¸ªåˆ‡ç‰‡åŒºåŸŸä¸­çš„å›¾çº¸ä¿¡æ¯ã€‚"""
            },
            slice_image
        ]
        
        return self.ai_analyzer._execute_vision_step(
            step_name="adapted_step1_drawing_info",
            system_prompt=system_prompt,
            user_content=user_content,
            task_id=task_id,
            drawing_id=drawing_id
        )

    def _adapted_step2_component_ids(self, 
                                    slice_config: SliceContextConfig,
                                    slice_image: Dict,
                                    drawing_info: Dict,
                                    task_id: str,
                                    drawing_id: int) -> Dict[str, Any]:
        """é€‚é…çš„æ­¥éª¤2ï¼šæ„ä»¶IDæå–ï¼ˆé’ˆå¯¹å±€éƒ¨åŒºåŸŸï¼‰"""
        
        system_prompt = f"""ä½ æ˜¯ä¸“ä¸šçš„å»ºç­‘å›¾çº¸åˆ†æä¸“å®¶ã€‚ç°åœ¨åˆ†æçš„æ˜¯å›¾çº¸çš„ä¸€ä¸ªå±€éƒ¨åˆ‡ç‰‡åŒºåŸŸã€‚

åˆ‡ç‰‡ä¿¡æ¯ï¼š
- åˆ‡ç‰‡ç±»å‹: {slice_config.slice_type}
- åˆ‡ç‰‡ä½ç½®: åŸå›¾çš„ ({slice_config.slice_bounds[0]}, {slice_config.slice_bounds[1]}) åŒºåŸŸ
- åˆ‡ç‰‡å°ºå¯¸: {slice_config.slice_bounds[2]}x{slice_config.slice_bounds[3]} åƒç´ 
- å…³æ³¨å†…å®¹: {', '.join(slice_config.focus_areas)}

å‰ç½®ä¿¡æ¯ï¼š
{json.dumps(drawing_info, ensure_ascii=False, indent=2)}

è¯·è¯†åˆ«è¿™ä¸ªåˆ‡ç‰‡åŒºåŸŸå†…çš„æ‰€æœ‰æ„ä»¶ç¼–å·å’Œæ ‡è¯†ã€‚ç”±äºè¿™æ˜¯å±€éƒ¨åŒºåŸŸï¼Œå¯èƒ½åªåŒ…å«éƒ¨åˆ†æ„ä»¶ã€‚

è¿”å›JSONæ ¼å¼ï¼š
{{
    "component_ids": [
        {{
            "id": "æ„ä»¶ç¼–å·",
            "type": "æ„ä»¶ç±»å‹",
            "location_in_slice": "åœ¨åˆ‡ç‰‡ä¸­çš„ä½ç½®æè¿°",
            "visibility": "complete/partial/annotation_only"
        }}
    ],
    "slice_summary": "è¿™ä¸ªåˆ‡ç‰‡åŒºåŸŸçš„æ„ä»¶æ¦‚è¿°"
}}"""
        
        user_content = [
            {
                "type": "text", 
                "text": f"è¯·åˆ†æè¿™ä¸ªåˆ‡ç‰‡åŒºåŸŸï¼ˆ{slice_config.slice_type}ï¼‰ä¸­çš„æ„ä»¶ç¼–å·å’Œæ ‡è¯†ã€‚"
            },
            slice_image
        ]
        
        return self.ai_analyzer._execute_vision_step(
            step_name="adapted_step2_component_ids",
            system_prompt=system_prompt,
            user_content=user_content,
            task_id=task_id,
            drawing_id=drawing_id
        )

    def _adapted_step3_component_counts(self, 
                                       slice_config: SliceContextConfig,
                                       slice_image: Dict,
                                       component_ids: Dict,
                                       task_id: str,
                                       drawing_id: int) -> Dict[str, Any]:
        """é€‚é…çš„æ­¥éª¤3ï¼šæ„ä»¶è®¡æ•°ï¼ˆé’ˆå¯¹åˆ‡ç‰‡å†…å®¹ï¼‰"""
        
        system_prompt = f"""åŸºäºå‰é¢è¯†åˆ«çš„æ„ä»¶IDï¼Œç»Ÿè®¡è¿™ä¸ªåˆ‡ç‰‡åŒºåŸŸå†…çš„æ„ä»¶æ•°é‡ã€‚

åˆ‡ç‰‡ä¿¡æ¯ï¼š
- åˆ‡ç‰‡ç±»å‹: {slice_config.slice_type}
- å…³æ³¨å†…å®¹: {', '.join(slice_config.focus_areas)}

å·²è¯†åˆ«æ„ä»¶ï¼š
{json.dumps(component_ids, ensure_ascii=False, indent=2)}

è¯·ç»Ÿè®¡æ¯ç§æ„ä»¶åœ¨è¿™ä¸ªåˆ‡ç‰‡åŒºåŸŸå†…çš„æ•°é‡ã€‚æ³¨æ„ï¼š
1. åªç»Ÿè®¡åœ¨æ­¤åˆ‡ç‰‡å†…å®Œæ•´å¯è§çš„æ„ä»¶
2. éƒ¨åˆ†å¯è§çš„æ„ä»¶éœ€è¦æ ‡æ³¨
3. å¦‚æœæ˜¯æ³¨é‡ŠåŒºåŸŸï¼Œç»Ÿè®¡æ ‡æ³¨çš„æ•°é‡

è¿”å›JSONæ ¼å¼ï¼š
{{
    "component_counts": {{
        "æ„ä»¶ç±»å‹": {{
            "complete_count": "å®Œæ•´å¯è§æ•°é‡",
            "partial_count": "éƒ¨åˆ†å¯è§æ•°é‡", 
            "annotation_count": "æ ‡æ³¨æ•°é‡",
            "total_in_slice": "åˆ‡ç‰‡å†…æ€»æ•°"
        }}
    }},
    "slice_coverage": "è¿™ä¸ªåˆ‡ç‰‡çš„è¦†ç›–èŒƒå›´è¯´æ˜"
}}"""
        
        user_content = [
            {
                "type": "text",
                "text": "è¯·ç»Ÿè®¡è¿™ä¸ªåˆ‡ç‰‡åŒºåŸŸå†…å„ç±»æ„ä»¶çš„æ•°é‡ã€‚"
            },
            slice_image
        ]
        
        return self.ai_analyzer._execute_vision_step(
            step_name="adapted_step3_component_counts",
            system_prompt=system_prompt,
            user_content=user_content,
            task_id=task_id,
            drawing_id=drawing_id
        )

    def _adapted_step4_positions(self, 
                                slice_config: SliceContextConfig,
                                slice_image: Dict,
                                previous_results: Dict,
                                task_id: str,
                                drawing_id: int) -> Dict[str, Any]:
        """é€‚é…çš„æ­¥éª¤4ï¼šä½ç½®ä¿¡æ¯æå–ï¼ˆç›¸å¯¹åˆ‡ç‰‡åæ ‡ï¼‰"""
        
        system_prompt = f"""æå–è¿™ä¸ªåˆ‡ç‰‡åŒºåŸŸå†…æ„ä»¶çš„ä½ç½®ä¿¡æ¯ã€‚

åˆ‡ç‰‡ä¿¡æ¯ï¼š
- åˆ‡ç‰‡åœ¨åŸå›¾ä¸­çš„ä½ç½®: ({slice_config.slice_bounds[0]}, {slice_config.slice_bounds[1]})
- åˆ‡ç‰‡å°ºå¯¸: {slice_config.slice_bounds[2]}x{slice_config.slice_bounds[3]}
- åŸå›¾å°ºå¯¸: {slice_config.original_image_size[0]}x{slice_config.original_image_size[1]}

å‰é¢çš„åˆ†æç»“æœï¼š
{json.dumps(previous_results, ensure_ascii=False, indent=2)}

è¯·æä¾›æ„ä»¶åœ¨åˆ‡ç‰‡å†…çš„ç›¸å¯¹åæ ‡ï¼ˆä»¥åˆ‡ç‰‡å·¦ä¸Šè§’ä¸ºåŸç‚¹ï¼‰ã€‚

è¿”å›JSONæ ¼å¼ï¼š
{{
    "component_positions": {{
        "æ„ä»¶ID": {{
            "slice_coordinates": {{
                "x": "åˆ‡ç‰‡å†…Xåæ ‡",
                "y": "åˆ‡ç‰‡å†…Yåæ ‡",
                "bbox": [x1, y1, x2, y2]
            }},
            "global_coordinates": {{
                "x": "åŸå›¾Xåæ ‡ï¼ˆåˆ‡ç‰‡åæ ‡+åç§»ï¼‰",
                "y": "åŸå›¾Yåæ ‡ï¼ˆåˆ‡ç‰‡åæ ‡+åç§»ï¼‰",
                "bbox": [x1, y1, x2, y2]
            }},
            "position_quality": "precise/approximate/estimated"
        }}
    }},
    "coordinate_system": "relative_to_slice"
}}"""
        
        user_content = [
            {
                "type": "text",
                "text": "è¯·æå–æ„ä»¶åœ¨è¿™ä¸ªåˆ‡ç‰‡å†…çš„ç²¾ç¡®ä½ç½®ä¿¡æ¯ã€‚"
            },
            slice_image
        ]
        
        return self.ai_analyzer._execute_vision_step(
            step_name="adapted_step4_positions",
            system_prompt=system_prompt,
            user_content=user_content,
            task_id=task_id,
            drawing_id=drawing_id
        )

    def _adapted_step5_attributes(self, 
                                 slice_config: SliceContextConfig,
                                 slice_image: Dict,
                                 previous_results: Dict,
                                 task_id: str,
                                 drawing_id: int) -> Dict[str, Any]:
        """é€‚é…çš„æ­¥éª¤5ï¼šå±æ€§æå–ï¼ˆè¯¦ç»†ä¿¡æ¯ï¼‰"""
        
        # æ ¹æ®åˆ‡ç‰‡ç±»å‹å’Œå…³æ³¨åŒºåŸŸè°ƒæ•´å±æ€§æå–é‡ç‚¹
        focus_attributes = []
        if 'dimensions' in slice_config.focus_areas:
            focus_attributes.append("å°ºå¯¸ä¿¡æ¯ï¼ˆé•¿ã€å®½ã€é«˜ã€åšåº¦ç­‰ï¼‰")
        if 'annotations' in slice_config.focus_areas:
            focus_attributes.append("æ ‡æ³¨ä¿¡æ¯ï¼ˆæ–‡å­—è¯´æ˜ã€è§„æ ¼æ ‡æ³¨ç­‰ï¼‰")
        if 'materials' in slice_config.focus_areas:
            focus_attributes.append("ææ–™ä¿¡æ¯ï¼ˆæ··å‡åœŸç­‰çº§ã€é’¢ç­‹è§„æ ¼ç­‰ï¼‰")
        if 'components' in slice_config.focus_areas:
            focus_attributes.append("æ„ä»¶è¯¦ç»†ä¿¡æ¯ï¼ˆç±»å‹ã€ç¼–å·ã€è¿æ¥æ–¹å¼ç­‰ï¼‰")
        
        system_prompt = f"""æå–è¿™ä¸ªåˆ‡ç‰‡åŒºåŸŸå†…æ„ä»¶çš„è¯¦ç»†å±æ€§ä¿¡æ¯ã€‚

åˆ‡ç‰‡åˆ†æé‡ç‚¹ï¼š
{chr(10).join(f'- {attr}' for attr in focus_attributes)}

å‰é¢çš„åˆ†æç»“æœï¼š
{json.dumps(previous_results, ensure_ascii=False, indent=2)}

è¯·é‡ç‚¹å…³æ³¨è¿™ä¸ªåˆ‡ç‰‡ç±»å‹ï¼ˆ{slice_config.slice_type}ï¼‰åº”è¯¥åŒ…å«çš„å±æ€§ä¿¡æ¯ã€‚

è¿”å›JSONæ ¼å¼ï¼š
{{
    "component_attributes": {{
        "æ„ä»¶ID": {{
            "dimensions": {{
                "raw_text": "åŸå§‹å°ºå¯¸æ–‡æœ¬",
                "length_m": "é•¿åº¦ï¼ˆç±³ï¼‰",
                "width_m": "å®½åº¦ï¼ˆç±³ï¼‰",
                "height_m": "é«˜åº¦ï¼ˆç±³ï¼‰"
            }},
            "material": {{
                "concrete_grade": "æ··å‡åœŸç­‰çº§",
                "steel_grade": "é’¢ç­‹ç­‰çº§",
                "other_materials": "å…¶ä»–ææ–™"
            }},
            "annotations": {{
                "visible_texts": ["å¯è§æ–‡å­—åˆ—è¡¨"],
                "dimension_markings": ["å°ºå¯¸æ ‡æ³¨"],
                "notes": "å¤‡æ³¨ä¿¡æ¯"
            }},
            "quality_indicators": {{
                "dimension_clarity": "å°ºå¯¸æ¸…æ™°åº¦",
                "annotation_completeness": "æ ‡æ³¨å®Œæ•´åº¦",
                "slice_coverage": "åˆ‡ç‰‡è¦†ç›–ç¨‹åº¦"
            }}
        }}
    }},
    "slice_analysis_summary": "è¿™ä¸ªåˆ‡ç‰‡çš„å±æ€§æå–æ€»ç»“"
}}"""
        
        user_content = [
            {
                "type": "text",
                "text": f"è¯·è¯¦ç»†æå–è¿™ä¸ª{slice_config.slice_type}åˆ‡ç‰‡ä¸­çš„æ„ä»¶å±æ€§ä¿¡æ¯ã€‚"
            },
            slice_image
        ]
        
        return self.ai_analyzer._execute_vision_step(
            step_name="adapted_step5_attributes",
            system_prompt=system_prompt,
            user_content=user_content,
            task_id=task_id,
            drawing_id=drawing_id
        )

    def _build_title_area_prompt(self) -> str:
        """æ„å»ºæ ‡é¢˜åŒºåŸŸä¸“ç”¨æç¤ºè¯"""
        return """ä½ æ˜¯ä¸“ä¸šçš„å»ºç­‘å›¾çº¸åˆ†æä¸“å®¶ã€‚è¿™æ˜¯å›¾çº¸çš„æ ‡é¢˜æ åŒºåŸŸåˆ‡ç‰‡ã€‚

è¯·é‡ç‚¹è¯†åˆ«ï¼š
1. å›¾çº¸æ ‡é¢˜å’Œå·¥ç¨‹åç§°
2. å›¾çº¸ç¼–å·å’Œç‰ˆæœ¬
3. æ¯”ä¾‹å°ºä¿¡æ¯
4. è®¾è®¡å•ä½å’Œè®¾è®¡å¸ˆ
5. æ—¥æœŸä¿¡æ¯
6. å›¾çº¸ç±»å‹ï¼ˆå¹³é¢å›¾ã€ç«‹é¢å›¾ã€å‰–é¢å›¾ç­‰ï¼‰

è¿”å›JSONæ ¼å¼ï¼š
{
    "drawing_info": {
        "title": "å›¾çº¸æ ‡é¢˜",
        "project_name": "å·¥ç¨‹åç§°", 
        "drawing_number": "å›¾çº¸ç¼–å·",
        "scale": "æ¯”ä¾‹å°º",
        "design_unit": "è®¾è®¡å•ä½",
        "designer": "è®¾è®¡å¸ˆ",
        "date": "æ—¥æœŸ",
        "drawing_type": "å›¾çº¸ç±»å‹"
    }
}"""

    def _build_detail_area_prompt(self) -> str:
        """æ„å»ºè¯¦å›¾åŒºåŸŸä¸“ç”¨æç¤ºè¯"""
        return """ä½ æ˜¯ä¸“ä¸šçš„å»ºç­‘å›¾çº¸åˆ†æä¸“å®¶ã€‚è¿™æ˜¯å›¾çº¸çš„è¯¦å›¾åŒºåŸŸåˆ‡ç‰‡ã€‚

è¯·é‡ç‚¹è¯†åˆ«ï¼š
1. è¯¦å›¾ä¸­çš„æ„ä»¶ä¿¡æ¯
2. è¯¦ç»†å°ºå¯¸æ ‡æ³¨
3. ææ–™è§„æ ¼è¯´æ˜
4. æ–½å·¥å·¥è‰ºè¦æ±‚
5. è¿æ¥èŠ‚ç‚¹ä¿¡æ¯

è¿”å›JSONæ ¼å¼ï¼š
{
    "drawing_info": {
        "detail_type": "è¯¦å›¾ç±»å‹",
        "scale": "è¯¦å›¾æ¯”ä¾‹",
        "focus_component": "ä¸»è¦æ„ä»¶"
    }
}"""

    def _build_general_slice_prompt(self, slice_config: SliceContextConfig) -> str:
        """æ„å»ºé€šç”¨åˆ‡ç‰‡æç¤ºè¯"""
        return f"""ä½ æ˜¯ä¸“ä¸šçš„å»ºç­‘å›¾çº¸åˆ†æä¸“å®¶ã€‚è¿™æ˜¯å›¾çº¸çš„ç¬¬{slice_config.slice_index + 1}ä¸ªåˆ‡ç‰‡åŒºåŸŸã€‚

åˆ‡ç‰‡ä¿¡æ¯ï¼š
- ç±»å‹: {slice_config.slice_type}
- å…³æ³¨å†…å®¹: {', '.join(slice_config.focus_areas)}
- ä½ç½®: åŸå›¾çš„ ({slice_config.slice_bounds[0]}, {slice_config.slice_bounds[1]}) åŒºåŸŸ

è¯·æ ¹æ®åˆ‡ç‰‡å†…å®¹è¯†åˆ«ç›¸å…³çš„å›¾çº¸ä¿¡æ¯ã€‚

è¿”å›JSONæ ¼å¼ï¼š
{{
    "drawing_info": {{
        "slice_type": "{slice_config.slice_type}",
        "identified_elements": "è¯†åˆ«åˆ°çš„å…ƒç´ åˆ—è¡¨",
        "partial_info": "ä»æ­¤åˆ‡ç‰‡è·å¾—çš„ä¿¡æ¯"
    }}
}}"""

    def _synthesize_slice_qto_data(self, 
                                  analysis_results: Dict[str, Any], 
                                  slice_config: SliceContextConfig) -> Dict[str, Any]:
        """åˆæˆåˆ‡ç‰‡çš„QTOæ•°æ®"""
        
        components = []
        
        # ä»å„æ­¥éª¤ç»“æœä¸­æå–æ„ä»¶ä¿¡æ¯
        component_ids = analysis_results.get("component_ids", {})
        component_counts = analysis_results.get("component_counts", {})
        component_positions = analysis_results.get("component_positions", {})
        component_attributes = analysis_results.get("component_attributes", {})
        
        # åˆå¹¶æ„ä»¶ä¿¡æ¯
        all_component_ids = component_ids.get("component_ids", [])
        
        for comp_id_info in all_component_ids:
            comp_id = comp_id_info.get("id", "")
            comp_type = comp_id_info.get("type", "")
            
            # æ„å»ºå®Œæ•´çš„æ„ä»¶ä¿¡æ¯
            component = {
                "component_id": comp_id,
                "component_type": comp_type,
                "slice_metadata": {
                    "slice_index": slice_config.slice_index,
                    "slice_id": slice_config.slice_id,
                    "slice_type": slice_config.slice_type,
                    "visibility": comp_id_info.get("visibility", "unknown"),
                    "location_in_slice": comp_id_info.get("location_in_slice", "")
                }
            }
            
            # æ·»åŠ è®¡æ•°ä¿¡æ¯
            counts = component_counts.get("component_counts", {}).get(comp_type, {})
            if counts:
                component["quantity"] = counts.get("total_in_slice", 1)
                component["count_details"] = counts
            
            # æ·»åŠ ä½ç½®ä¿¡æ¯
            positions = component_positions.get("component_positions", {}).get(comp_id, {})
            if positions:
                component["position"] = positions.get("global_coordinates", {})
                component["slice_position"] = positions.get("slice_coordinates", {})
                component["position_quality"] = positions.get("position_quality", "estimated")
            
            # æ·»åŠ å±æ€§ä¿¡æ¯
            attributes = component_attributes.get("component_attributes", {}).get(comp_id, {})
            if attributes:
                component["dimensions"] = attributes.get("dimensions", {})
                component["material"] = attributes.get("material", {})
                component["annotations"] = attributes.get("annotations", {})
                component["quality_indicators"] = attributes.get("quality_indicators", {})
            
            components.append(component)
        
        # ç”ŸæˆQTOæ•°æ®
        qto_data = {
            "drawing_info": analysis_results.get("drawing_info", {}),
            "components": components,
            "quantity_summary": {
                "åˆ‡ç‰‡æ„ä»¶æ€»æ•°": len(components),
                "åˆ‡ç‰‡ç±»å‹": slice_config.slice_type
            },
            "analysis_metadata": {
                "slice_config": {
                    "slice_index": slice_config.slice_index,
                    "slice_id": slice_config.slice_id,
                    "slice_type": slice_config.slice_type,
                    "slice_bounds": slice_config.slice_bounds,
                    "focus_areas": slice_config.focus_areas
                },
                "steps_completed": analysis_results.get("slice_metadata", {}).get("steps_completed", []),
                "analysis_method": "slice_adapted_five_step",
                "coordinate_system": "slice_relative_with_global_mapping"
            }
        }
        
        return qto_data

    def _merge_slice_analysis_results(self, 
                                    slice_results: List[Dict[str, Any]], 
                                    task_id: str) -> Dict[str, Any]:
        """åˆå¹¶æ‰€æœ‰åˆ‡ç‰‡çš„åˆ†æç»“æœ"""
        
        logger.info(f"ğŸ”„ å¼€å§‹åˆå¹¶ {len(slice_results)} ä¸ªåˆ‡ç‰‡çš„åˆ†æç»“æœ")
        
        # æ”¶é›†æ‰€æœ‰æˆåŠŸçš„ç»“æœ
        successful_results = [r for r in slice_results if r['analysis_result'].get('success')]
        
        if not successful_results:
            return {
                "success": False,
                "error": "No successful slice analysis results",
                "total_slices": len(slice_results)
            }
        
        # åˆå¹¶å›¾çº¸ä¿¡æ¯
        merged_drawing_info = {}
        for result in successful_results:
            qto_data = result['analysis_result'].get('qto_data', {})
            drawing_info = qto_data.get('drawing_info', {})
            
            # ä¼˜å…ˆä¿ç•™éç©ºå€¼
            for key, value in drawing_info.items():
                if value and (key not in merged_drawing_info or not merged_drawing_info[key]):
                    merged_drawing_info[key] = value
        
        # åˆå¹¶æ„ä»¶ä¿¡æ¯
        all_components = []
        for result in successful_results:
            qto_data = result['analysis_result'].get('qto_data', {})
            components = qto_data.get('components', [])
            all_components.extend(components)
        
        # ç”Ÿæˆæœ€ç»ˆç»“æœ
        merged_result = {
            "success": True,
            "qto_data": {
                "drawing_info": merged_drawing_info,
                "components": all_components,
                "quantity_summary": {
                    "æ€»æ„ä»¶æ•°": len(all_components),
                    "åˆ‡ç‰‡æ•°é‡": len(successful_results),
                    "æˆåŠŸç‡": f"{len(successful_results)}/{len(slice_results)}"
                },
                "analysis_metadata": {
                    "merge_method": "slice_adapted_multi_turn",
                    "total_slices": len(slice_results),
                    "successful_slices": len(successful_results),
                    "analysis_timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                    "task_id": task_id
                }
            },
            "slice_results": slice_results
        }
        
        logger.info(f"âœ… åˆ‡ç‰‡åˆ†æç»“æœåˆå¹¶å®Œæˆ: {len(all_components)} ä¸ªæ„ä»¶")
        return merged_result

# å…¨å±€å®ä¾‹
slice_vision_adapter = SliceVisionAdapter()