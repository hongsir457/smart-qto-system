# 🏗️ 工程量智能计算系统设计方案

## 🎯 系统目标

基于**国家标准图集**和**工程量清单计价规范（GB 50500-2013）**，实现建筑图纸的智能识别和工程量自动计算。

## 📋 核心技术架构

### 1. 图集规范识别模块

#### 🔍 国标图集支持
```python
# 支持的主要图集
SUPPORTED_ATLASES = {
    "11G101": "混凝土结构施工图平面整体表示方法制图规则和构造详图",
    "16G101": "混凝土结构施工图平面整体表示方法制图规则和构造详图(现行版)",
    "18G901": "混凝土结构施工图平面整体表示方法制图规则和构造详图(住宅建筑)",
    "11G329": "建筑物抗震构造详图",
    "06SG114": "钢筋混凝土小型构件",
}

# 构件标准符号识别
COMPONENT_SYMBOLS = {
    # 柱子符号
    "KZ": "框架柱",
    "XZ": "芯柱", 
    "LZ": "梁上柱",
    "QZ": "剪力墙边缘构件",
    
    # 梁符号
    "KL": "框架梁",
    "LL": "连梁",
    "WKL": "屋面框架梁",
    "JL": "基础梁",
    "XL": "小梁",
    
    # 板符号
    "LB": "楼板",
    "WB": "屋面板",
    "YXB": "预应力板",
    
    # 基础符号
    "DJJ": "独立基础",
    "CFJ": "筏板基础",
    "DTJ": "条形基础",
}
```

#### 📐 制图规则解析
```python
# 制图规则引擎
class DrawingRuleEngine:
    def __init__(self):
        self.scale_rules = {
            "1:50": {"min_line_width": 0.35, "text_height": 3.5},
            "1:100": {"min_line_width": 0.25, "text_height": 2.5},
            "1:200": {"min_line_width": 0.18, "text_height": 1.8},
        }
        
    def detect_drawing_scale(self, image):
        """识别图纸比例"""
        pass
        
    def extract_dimension_annotations(self, image):
        """提取尺寸标注"""
        pass
        
    def recognize_material_symbols(self, image):
        """识别材料符号"""
        pass
```

### 2. 工程量计算规范模块

#### 📊 GB 50500-2013 计算规则
```python
# 工程量计算规则引擎
class QuantityCalculationEngine:
    def __init__(self):
        self.calculation_rules = {
            # 混凝土工程（按体积计算）
            "concrete": {
                "columns": self._calculate_column_concrete,
                "beams": self._calculate_beam_concrete, 
                "slabs": self._calculate_slab_concrete,
                "foundations": self._calculate_foundation_concrete,
            },
            
            # 钢筋工程（按重量计算）
            "reinforcement": {
                "columns": self._calculate_column_rebar,
                "beams": self._calculate_beam_rebar,
                "slabs": self._calculate_slab_rebar,
            },
            
            # 模板工程（按面积计算）
            "formwork": {
                "columns": self._calculate_column_formwork,
                "beams": self._calculate_beam_formwork,
                "slabs": self._calculate_slab_formwork,
            }
        }
        
    def _calculate_column_concrete(self, column_data):
        """柱混凝土工程量 = 截面积 × 高度 - 扣减量"""
        section_area = column_data['width'] * column_data['depth'] / 1000000  # 转换为m²
        height = column_data['height'] / 1000  # 转换为m
        
        # 扣减梁柱节点重复计算部分
        beam_deduction = self._calculate_beam_intersection_volume(column_data)
        
        volume = section_area * height - beam_deduction
        return max(0, volume)  # 确保不为负数
        
    def _calculate_beam_concrete(self, beam_data):
        """梁混凝土工程量 = 截面积 × 长度"""
        section_area = beam_data['width'] * beam_data['height'] / 1000000
        length = beam_data['length'] / 1000
        return section_area * length
        
    def _calculate_slab_concrete(self, slab_data):
        """板混凝土工程量 = 面积 × 厚度 - 洞口扣减"""
        area = slab_data['area'] / 1000000  # 转换为m²
        thickness = slab_data['thickness'] / 1000  # 转换为m
        
        # 扣减洞口面积
        opening_deduction = sum(opening['area'] for opening in slab_data.get('openings', []))
        
        volume = (area - opening_deduction) * thickness
        return max(0, volume)
```

### 3. 智能识别流程

#### 🔄 多层次识别架构
```python
class IntelligentRecognitionPipeline:
    def __init__(self):
        self.ocr_engine = OCREngine()  # 文字识别
        self.symbol_detector = SymbolDetector()  # 符号检测
        self.dimension_extractor = DimensionExtractor()  # 尺寸提取
        self.component_analyzer = ComponentAnalyzer()  # 构件分析
        
    def process_drawing(self, image_path):
        """处理建筑图纸的完整流程"""
        
        # Step 1: 图纸预处理
        processed_image = self._preprocess_drawing(image_path)
        
        # Step 2: 图纸信息识别
        drawing_info = self._extract_drawing_info(processed_image)
        
        # Step 3: 构件符号识别
        components = self._detect_components_with_symbols(processed_image)
        
        # Step 4: 尺寸标注提取
        dimensions = self._extract_dimensions(processed_image)
        
        # Step 5: 构件信息关联
        enriched_components = self._associate_components_with_dimensions(
            components, dimensions
        )
        
        # Step 6: 工程量计算
        quantities = self._calculate_quantities(enriched_components)
        
        return {
            "drawing_info": drawing_info,
            "components": enriched_components,
            "quantities": quantities
        }
```

## 🛠️ 核心技术实现

### 1. OCR + 符号识别
```python
class AdvancedOCREngine:
    def __init__(self):
        self.text_ocr = PaddleOCR(use_angle_cls=True, lang='ch')
        self.symbol_detector = YOLO('construction_symbols.pt')
        
    def extract_text_and_symbols(self, image):
        """提取图纸中的文字和符号"""
        
        # 文字识别
        text_results = self.text_ocr.ocr(image, cls=True)
        
        # 符号检测
        symbol_results = self.symbol_detector(image)
        
        # 构件编号匹配
        component_codes = self._match_component_codes(text_results)
        
        return {
            "texts": text_results,
            "symbols": symbol_results,
            "component_codes": component_codes
        }
        
    def _match_component_codes(self, text_results):
        """匹配构件编号（如KZ1、KL2等）"""
        import re
        component_pattern = r'([A-Z]{1,3})(\d+)'
        
        components = []
        for line in text_results:
            text = line[1][0]
            matches = re.findall(component_pattern, text)
            for match in matches:
                components.append({
                    "type": match[0],
                    "number": match[1],
                    "position": line[0],
                    "confidence": line[1][1]
                })
        return components
```

### 2. 尺寸标注智能提取
```python
class DimensionExtractor:
    def __init__(self):
        self.line_detector = cv2.createLineSegmentDetector()
        
    def extract_dimensions(self, image):
        """提取尺寸标注"""
        
        # 检测直线（尺寸线）
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        lines = self.line_detector.detect(gray)[0]
        
        # 检测尺寸数字
        dimension_texts = self._detect_dimension_numbers(image)
        
        # 关联尺寸线和数字
        dimensions = self._associate_lines_with_numbers(lines, dimension_texts)
        
        return dimensions
        
    def _detect_dimension_numbers(self, image):
        """检测尺寸数字"""
        # 使用OCR识别数字，过滤出尺寸相关的文字
        ocr_results = self.ocr.ocr(image)
        
        dimension_pattern = r'(\d+(?:\.\d+)?)'  # 匹配数字
        dimensions = []
        
        for result in ocr_results:
            text = result[1][0]
            if re.match(dimension_pattern, text):
                dimensions.append({
                    "value": float(text),
                    "position": result[0],
                    "bbox": result[0]
                })
        
        return dimensions
```

### 3. 工程量统计规则引擎
```python
class QuantitySummaryEngine:
    def __init__(self):
        self.gb50500_rules = GB50500Rules()
        
    def generate_quantity_list(self, components):
        """生成工程量清单"""
        
        quantity_list = {
            "010101001": {  # 现浇混凝土柱
                "name": "现浇混凝土柱",
                "unit": "m³",
                "quantity": 0,
                "components": []
            },
            "010101002": {  # 现浇混凝土梁
                "name": "现浇混凝土梁", 
                "unit": "m³",
                "quantity": 0,
                "components": []
            },
            "010101003": {  # 现浇混凝土板
                "name": "现浇混凝土板",
                "unit": "m³", 
                "quantity": 0,
                "components": []
            }
        }
        
        # 按构件类型统计工程量
        for component in components:
            comp_type = component['type']
            volume = component['calculated_volume']
            
            if comp_type == 'column':
                quantity_list["010101001"]["quantity"] += volume
                quantity_list["010101001"]["components"].append(component)
            elif comp_type == 'beam':
                quantity_list["010101002"]["quantity"] += volume
                quantity_list["010101002"]["components"].append(component)
            elif comp_type == 'slab':
                quantity_list["010101003"]["quantity"] += volume
                quantity_list["010101003"]["components"].append(component)
                
        return quantity_list
```

## 📊 数据库设计

### 构件标准库
```sql
-- 构件标准表
CREATE TABLE component_standards (
    id INT PRIMARY KEY,
    component_code VARCHAR(10),  -- KZ1, KL2等
    component_type VARCHAR(20),  -- column, beam, slab
    section_width DECIMAL(8,2),  -- 截面宽度(mm)
    section_height DECIMAL(8,2), -- 截面高度(mm)
    concrete_grade VARCHAR(10),  -- C30, C35等
    rebar_grade VARCHAR(10),     -- HRB400, HRB500等
    atlas_reference VARCHAR(50)  -- 图集来源
);

-- 计算规则表
CREATE TABLE calculation_rules (
    id INT PRIMARY KEY,
    rule_code VARCHAR(20),       -- GB50500条目编码
    rule_name VARCHAR(100),      -- 规则名称
    calculation_method TEXT,     -- 计算方法描述
    unit VARCHAR(10),            -- 计量单位
    deduction_rules TEXT         -- 扣减规则
);
```

## 🎯 实施路线图

### 阶段一：基础识别能力（2周）
1. ✅ 部署YOLOv8x模型
2. 🔄 集成OCR引擎（PaddleOCR）
3. 🔄 构建符号识别数据集
4. 🔄 实现基础尺寸提取

### 阶段二：规范化识别（4周）
1. 📋 构建国标图集符号库
2. 📐 实现制图规则解析
3. 🔍 开发智能尺寸关联算法
4. 🧮 构建工程量计算引擎

### 阶段三：精准计算（4周）
1. 📊 实现GB50500计算规则
2. ⚖️ 开发扣减规则引擎
3. 📈 构建工程量汇总系统
4. 📄 生成标准清单报表

## 💡 创新特色

### 1. 多模态融合识别
- **深度学习** + **OCR** + **几何分析**
- **符号检测** + **文字识别** + **尺寸关联**

### 2. 规范化知识图谱
- 集成国标图集知识库
- 构建构件关系网络
- 实现智能推理计算

### 3. 自适应计算引擎
- 支持多种计算规范
- 自动选择计算规则
- 智能处理特殊情况

这个系统将真正实现从**"看图识字"**到**"专业计算"**的跨越！🚀 