# ğŸ—ï¸ å·¥ç¨‹é‡æ™ºèƒ½è®¡ç®—ç³»ç»Ÿè®¾è®¡æ–¹æ¡ˆ

## ğŸ¯ ç³»ç»Ÿç›®æ ‡

åŸºäº**å›½å®¶æ ‡å‡†å›¾é›†**å’Œ**å·¥ç¨‹é‡æ¸…å•è®¡ä»·è§„èŒƒï¼ˆGB 50500-2013ï¼‰**ï¼Œå®ç°å»ºç­‘å›¾çº¸çš„æ™ºèƒ½è¯†åˆ«å’Œå·¥ç¨‹é‡è‡ªåŠ¨è®¡ç®—ã€‚

## ğŸ“‹ æ ¸å¿ƒæŠ€æœ¯æ¶æ„

### 1. å›¾é›†è§„èŒƒè¯†åˆ«æ¨¡å—

#### ğŸ” å›½æ ‡å›¾é›†æ”¯æŒ
```python
# æ”¯æŒçš„ä¸»è¦å›¾é›†
SUPPORTED_ATLASES = {
    "11G101": "æ··å‡åœŸç»“æ„æ–½å·¥å›¾å¹³é¢æ•´ä½“è¡¨ç¤ºæ–¹æ³•åˆ¶å›¾è§„åˆ™å’Œæ„é€ è¯¦å›¾",
    "16G101": "æ··å‡åœŸç»“æ„æ–½å·¥å›¾å¹³é¢æ•´ä½“è¡¨ç¤ºæ–¹æ³•åˆ¶å›¾è§„åˆ™å’Œæ„é€ è¯¦å›¾(ç°è¡Œç‰ˆ)",
    "18G901": "æ··å‡åœŸç»“æ„æ–½å·¥å›¾å¹³é¢æ•´ä½“è¡¨ç¤ºæ–¹æ³•åˆ¶å›¾è§„åˆ™å’Œæ„é€ è¯¦å›¾(ä½å®…å»ºç­‘)",
    "11G329": "å»ºç­‘ç‰©æŠ—éœ‡æ„é€ è¯¦å›¾",
    "06SG114": "é’¢ç­‹æ··å‡åœŸå°å‹æ„ä»¶",
}

# æ„ä»¶æ ‡å‡†ç¬¦å·è¯†åˆ«
COMPONENT_SYMBOLS = {
    # æŸ±å­ç¬¦å·
    "KZ": "æ¡†æ¶æŸ±",
    "XZ": "èŠ¯æŸ±", 
    "LZ": "æ¢ä¸ŠæŸ±",
    "QZ": "å‰ªåŠ›å¢™è¾¹ç¼˜æ„ä»¶",
    
    # æ¢ç¬¦å·
    "KL": "æ¡†æ¶æ¢",
    "LL": "è¿æ¢",
    "WKL": "å±‹é¢æ¡†æ¶æ¢",
    "JL": "åŸºç¡€æ¢",
    "XL": "å°æ¢",
    
    # æ¿ç¬¦å·
    "LB": "æ¥¼æ¿",
    "WB": "å±‹é¢æ¿",
    "YXB": "é¢„åº”åŠ›æ¿",
    
    # åŸºç¡€ç¬¦å·
    "DJJ": "ç‹¬ç«‹åŸºç¡€",
    "CFJ": "ç­æ¿åŸºç¡€",
    "DTJ": "æ¡å½¢åŸºç¡€",
}
```

#### ğŸ“ åˆ¶å›¾è§„åˆ™è§£æ
```python
# åˆ¶å›¾è§„åˆ™å¼•æ“
class DrawingRuleEngine:
    def __init__(self):
        self.scale_rules = {
            "1:50": {"min_line_width": 0.35, "text_height": 3.5},
            "1:100": {"min_line_width": 0.25, "text_height": 2.5},
            "1:200": {"min_line_width": 0.18, "text_height": 1.8},
        }
        
    def detect_drawing_scale(self, image):
        """è¯†åˆ«å›¾çº¸æ¯”ä¾‹"""
        pass
        
    def extract_dimension_annotations(self, image):
        """æå–å°ºå¯¸æ ‡æ³¨"""
        pass
        
    def recognize_material_symbols(self, image):
        """è¯†åˆ«ææ–™ç¬¦å·"""
        pass
```

### 2. å·¥ç¨‹é‡è®¡ç®—è§„èŒƒæ¨¡å—

#### ğŸ“Š GB 50500-2013 è®¡ç®—è§„åˆ™
```python
# å·¥ç¨‹é‡è®¡ç®—è§„åˆ™å¼•æ“
class QuantityCalculationEngine:
    def __init__(self):
        self.calculation_rules = {
            # æ··å‡åœŸå·¥ç¨‹ï¼ˆæŒ‰ä½“ç§¯è®¡ç®—ï¼‰
            "concrete": {
                "columns": self._calculate_column_concrete,
                "beams": self._calculate_beam_concrete, 
                "slabs": self._calculate_slab_concrete,
                "foundations": self._calculate_foundation_concrete,
            },
            
            # é’¢ç­‹å·¥ç¨‹ï¼ˆæŒ‰é‡é‡è®¡ç®—ï¼‰
            "reinforcement": {
                "columns": self._calculate_column_rebar,
                "beams": self._calculate_beam_rebar,
                "slabs": self._calculate_slab_rebar,
            },
            
            # æ¨¡æ¿å·¥ç¨‹ï¼ˆæŒ‰é¢ç§¯è®¡ç®—ï¼‰
            "formwork": {
                "columns": self._calculate_column_formwork,
                "beams": self._calculate_beam_formwork,
                "slabs": self._calculate_slab_formwork,
            }
        }
        
    def _calculate_column_concrete(self, column_data):
        """æŸ±æ··å‡åœŸå·¥ç¨‹é‡ = æˆªé¢ç§¯ Ã— é«˜åº¦ - æ‰£å‡é‡"""
        section_area = column_data['width'] * column_data['depth'] / 1000000  # è½¬æ¢ä¸ºmÂ²
        height = column_data['height'] / 1000  # è½¬æ¢ä¸ºm
        
        # æ‰£å‡æ¢æŸ±èŠ‚ç‚¹é‡å¤è®¡ç®—éƒ¨åˆ†
        beam_deduction = self._calculate_beam_intersection_volume(column_data)
        
        volume = section_area * height - beam_deduction
        return max(0, volume)  # ç¡®ä¿ä¸ä¸ºè´Ÿæ•°
        
    def _calculate_beam_concrete(self, beam_data):
        """æ¢æ··å‡åœŸå·¥ç¨‹é‡ = æˆªé¢ç§¯ Ã— é•¿åº¦"""
        section_area = beam_data['width'] * beam_data['height'] / 1000000
        length = beam_data['length'] / 1000
        return section_area * length
        
    def _calculate_slab_concrete(self, slab_data):
        """æ¿æ··å‡åœŸå·¥ç¨‹é‡ = é¢ç§¯ Ã— åšåº¦ - æ´å£æ‰£å‡"""
        area = slab_data['area'] / 1000000  # è½¬æ¢ä¸ºmÂ²
        thickness = slab_data['thickness'] / 1000  # è½¬æ¢ä¸ºm
        
        # æ‰£å‡æ´å£é¢ç§¯
        opening_deduction = sum(opening['area'] for opening in slab_data.get('openings', []))
        
        volume = (area - opening_deduction) * thickness
        return max(0, volume)
```

### 3. æ™ºèƒ½è¯†åˆ«æµç¨‹

#### ğŸ”„ å¤šå±‚æ¬¡è¯†åˆ«æ¶æ„
```python
class IntelligentRecognitionPipeline:
    def __init__(self):
        self.ocr_engine = OCREngine()  # æ–‡å­—è¯†åˆ«
        self.symbol_detector = SymbolDetector()  # ç¬¦å·æ£€æµ‹
        self.dimension_extractor = DimensionExtractor()  # å°ºå¯¸æå–
        self.component_analyzer = ComponentAnalyzer()  # æ„ä»¶åˆ†æ
        
    def process_drawing(self, image_path):
        """å¤„ç†å»ºç­‘å›¾çº¸çš„å®Œæ•´æµç¨‹"""
        
        # Step 1: å›¾çº¸é¢„å¤„ç†
        processed_image = self._preprocess_drawing(image_path)
        
        # Step 2: å›¾çº¸ä¿¡æ¯è¯†åˆ«
        drawing_info = self._extract_drawing_info(processed_image)
        
        # Step 3: æ„ä»¶ç¬¦å·è¯†åˆ«
        components = self._detect_components_with_symbols(processed_image)
        
        # Step 4: å°ºå¯¸æ ‡æ³¨æå–
        dimensions = self._extract_dimensions(processed_image)
        
        # Step 5: æ„ä»¶ä¿¡æ¯å…³è”
        enriched_components = self._associate_components_with_dimensions(
            components, dimensions
        )
        
        # Step 6: å·¥ç¨‹é‡è®¡ç®—
        quantities = self._calculate_quantities(enriched_components)
        
        return {
            "drawing_info": drawing_info,
            "components": enriched_components,
            "quantities": quantities
        }
```

## ğŸ› ï¸ æ ¸å¿ƒæŠ€æœ¯å®ç°

### 1. OCR + ç¬¦å·è¯†åˆ«
```python
class AdvancedOCREngine:
    def __init__(self):
        self.text_ocr = PaddleOCR(use_angle_cls=True, lang='ch')
        self.symbol_detector = YOLO('construction_symbols.pt')
        
    def extract_text_and_symbols(self, image):
        """æå–å›¾çº¸ä¸­çš„æ–‡å­—å’Œç¬¦å·"""
        
        # æ–‡å­—è¯†åˆ«
        text_results = self.text_ocr.ocr(image, cls=True)
        
        # ç¬¦å·æ£€æµ‹
        symbol_results = self.symbol_detector(image)
        
        # æ„ä»¶ç¼–å·åŒ¹é…
        component_codes = self._match_component_codes(text_results)
        
        return {
            "texts": text_results,
            "symbols": symbol_results,
            "component_codes": component_codes
        }
        
    def _match_component_codes(self, text_results):
        """åŒ¹é…æ„ä»¶ç¼–å·ï¼ˆå¦‚KZ1ã€KL2ç­‰ï¼‰"""
        import re
        component_pattern = r'([A-Z]{1,3})(\d+)'
        
        components = []
        for line in text_results:
            text = line[1][0]
            matches = re.findall(component_pattern, text)
            for match in matches:
                components.append({
                    "type": match[0],
                    "number": match[1],
                    "position": line[0],
                    "confidence": line[1][1]
                })
        return components
```

### 2. å°ºå¯¸æ ‡æ³¨æ™ºèƒ½æå–
```python
class DimensionExtractor:
    def __init__(self):
        self.line_detector = cv2.createLineSegmentDetector()
        
    def extract_dimensions(self, image):
        """æå–å°ºå¯¸æ ‡æ³¨"""
        
        # æ£€æµ‹ç›´çº¿ï¼ˆå°ºå¯¸çº¿ï¼‰
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        lines = self.line_detector.detect(gray)[0]
        
        # æ£€æµ‹å°ºå¯¸æ•°å­—
        dimension_texts = self._detect_dimension_numbers(image)
        
        # å…³è”å°ºå¯¸çº¿å’Œæ•°å­—
        dimensions = self._associate_lines_with_numbers(lines, dimension_texts)
        
        return dimensions
        
    def _detect_dimension_numbers(self, image):
        """æ£€æµ‹å°ºå¯¸æ•°å­—"""
        # ä½¿ç”¨OCRè¯†åˆ«æ•°å­—ï¼Œè¿‡æ»¤å‡ºå°ºå¯¸ç›¸å…³çš„æ–‡å­—
        ocr_results = self.ocr.ocr(image)
        
        dimension_pattern = r'(\d+(?:\.\d+)?)'  # åŒ¹é…æ•°å­—
        dimensions = []
        
        for result in ocr_results:
            text = result[1][0]
            if re.match(dimension_pattern, text):
                dimensions.append({
                    "value": float(text),
                    "position": result[0],
                    "bbox": result[0]
                })
        
        return dimensions
```

### 3. å·¥ç¨‹é‡ç»Ÿè®¡è§„åˆ™å¼•æ“
```python
class QuantitySummaryEngine:
    def __init__(self):
        self.gb50500_rules = GB50500Rules()
        
    def generate_quantity_list(self, components):
        """ç”Ÿæˆå·¥ç¨‹é‡æ¸…å•"""
        
        quantity_list = {
            "010101001": {  # ç°æµ‡æ··å‡åœŸæŸ±
                "name": "ç°æµ‡æ··å‡åœŸæŸ±",
                "unit": "mÂ³",
                "quantity": 0,
                "components": []
            },
            "010101002": {  # ç°æµ‡æ··å‡åœŸæ¢
                "name": "ç°æµ‡æ··å‡åœŸæ¢", 
                "unit": "mÂ³",
                "quantity": 0,
                "components": []
            },
            "010101003": {  # ç°æµ‡æ··å‡åœŸæ¿
                "name": "ç°æµ‡æ··å‡åœŸæ¿",
                "unit": "mÂ³", 
                "quantity": 0,
                "components": []
            }
        }
        
        # æŒ‰æ„ä»¶ç±»å‹ç»Ÿè®¡å·¥ç¨‹é‡
        for component in components:
            comp_type = component['type']
            volume = component['calculated_volume']
            
            if comp_type == 'column':
                quantity_list["010101001"]["quantity"] += volume
                quantity_list["010101001"]["components"].append(component)
            elif comp_type == 'beam':
                quantity_list["010101002"]["quantity"] += volume
                quantity_list["010101002"]["components"].append(component)
            elif comp_type == 'slab':
                quantity_list["010101003"]["quantity"] += volume
                quantity_list["010101003"]["components"].append(component)
                
        return quantity_list
```

## ğŸ“Š æ•°æ®åº“è®¾è®¡

### æ„ä»¶æ ‡å‡†åº“
```sql
-- æ„ä»¶æ ‡å‡†è¡¨
CREATE TABLE component_standards (
    id INT PRIMARY KEY,
    component_code VARCHAR(10),  -- KZ1, KL2ç­‰
    component_type VARCHAR(20),  -- column, beam, slab
    section_width DECIMAL(8,2),  -- æˆªé¢å®½åº¦(mm)
    section_height DECIMAL(8,2), -- æˆªé¢é«˜åº¦(mm)
    concrete_grade VARCHAR(10),  -- C30, C35ç­‰
    rebar_grade VARCHAR(10),     -- HRB400, HRB500ç­‰
    atlas_reference VARCHAR(50)  -- å›¾é›†æ¥æº
);

-- è®¡ç®—è§„åˆ™è¡¨
CREATE TABLE calculation_rules (
    id INT PRIMARY KEY,
    rule_code VARCHAR(20),       -- GB50500æ¡ç›®ç¼–ç 
    rule_name VARCHAR(100),      -- è§„åˆ™åç§°
    calculation_method TEXT,     -- è®¡ç®—æ–¹æ³•æè¿°
    unit VARCHAR(10),            -- è®¡é‡å•ä½
    deduction_rules TEXT         -- æ‰£å‡è§„åˆ™
);
```

## ğŸ¯ å®æ–½è·¯çº¿å›¾

### é˜¶æ®µä¸€ï¼šåŸºç¡€è¯†åˆ«èƒ½åŠ›ï¼ˆ2å‘¨ï¼‰
1. âœ… éƒ¨ç½²YOLOv8xæ¨¡å‹
2. ğŸ”„ é›†æˆOCRå¼•æ“ï¼ˆPaddleOCRï¼‰
3. ğŸ”„ æ„å»ºç¬¦å·è¯†åˆ«æ•°æ®é›†
4. ğŸ”„ å®ç°åŸºç¡€å°ºå¯¸æå–

### é˜¶æ®µäºŒï¼šè§„èŒƒåŒ–è¯†åˆ«ï¼ˆ4å‘¨ï¼‰
1. ğŸ“‹ æ„å»ºå›½æ ‡å›¾é›†ç¬¦å·åº“
2. ğŸ“ å®ç°åˆ¶å›¾è§„åˆ™è§£æ
3. ğŸ” å¼€å‘æ™ºèƒ½å°ºå¯¸å…³è”ç®—æ³•
4. ğŸ§® æ„å»ºå·¥ç¨‹é‡è®¡ç®—å¼•æ“

### é˜¶æ®µä¸‰ï¼šç²¾å‡†è®¡ç®—ï¼ˆ4å‘¨ï¼‰
1. ğŸ“Š å®ç°GB50500è®¡ç®—è§„åˆ™
2. âš–ï¸ å¼€å‘æ‰£å‡è§„åˆ™å¼•æ“
3. ğŸ“ˆ æ„å»ºå·¥ç¨‹é‡æ±‡æ€»ç³»ç»Ÿ
4. ğŸ“„ ç”Ÿæˆæ ‡å‡†æ¸…å•æŠ¥è¡¨

## ğŸ’¡ åˆ›æ–°ç‰¹è‰²

### 1. å¤šæ¨¡æ€èåˆè¯†åˆ«
- **æ·±åº¦å­¦ä¹ ** + **OCR** + **å‡ ä½•åˆ†æ**
- **ç¬¦å·æ£€æµ‹** + **æ–‡å­—è¯†åˆ«** + **å°ºå¯¸å…³è”**

### 2. è§„èŒƒåŒ–çŸ¥è¯†å›¾è°±
- é›†æˆå›½æ ‡å›¾é›†çŸ¥è¯†åº“
- æ„å»ºæ„ä»¶å…³ç³»ç½‘ç»œ
- å®ç°æ™ºèƒ½æ¨ç†è®¡ç®—

### 3. è‡ªé€‚åº”è®¡ç®—å¼•æ“
- æ”¯æŒå¤šç§è®¡ç®—è§„èŒƒ
- è‡ªåŠ¨é€‰æ‹©è®¡ç®—è§„åˆ™
- æ™ºèƒ½å¤„ç†ç‰¹æ®Šæƒ…å†µ

è¿™ä¸ªç³»ç»Ÿå°†çœŸæ­£å®ç°ä»**"çœ‹å›¾è¯†å­—"**åˆ°**"ä¸“ä¸šè®¡ç®—"**çš„è·¨è¶Šï¼ğŸš€ 